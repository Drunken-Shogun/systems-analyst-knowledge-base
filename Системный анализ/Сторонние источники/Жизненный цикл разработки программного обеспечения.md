***

### Что такое SDLC?
```
Software Development Life Cycle (SDLC) — это пошаговый процесс разработки, который начинается с идеи и заканчивается готовым продуктом. Учитывать жизненный цикл нужно, чтобы хотя бы примерно начертить план работ и распределить ресурсы сотрудников, иначе разработка превратится в хаос.
```

***

## Этапы 

>[!warning]-
> Использовался обобщённый, наиболее распространённый вариант! Существуют различия в трактовке и названиях этапов от источника к источнику.

### Планирование

> [!tldr]- Кратко!
> На этом этапе формируются бизнес-требования к ПО

Цель первого этапа - **определить четкие цели и выявить, что необходимо** для их достижения. На этом начальном этапе команды должны учитывать потребности заинтересованных лиц, чтобы решить [как создать ваше приложение](https://www.microsoft.com/ru-ru/power-platform/products/power-apps/topics/app-development) и когда оно будет развернуто.  
  
Планирование проекта обеспечивает **понимание всеми участниками того, что должно предлагать ваше ПО**, подтверждая доступность всех необходимых ресурсов, например времени и бюджета. Этот этап SDLC имеет решающее значение, поскольку помогает предотвратить технические проблемы и неожиданные расходы, которые могут задержать или сорвать ваш проект.

> [!todo]- Проводимые работы
>- Описание задач, которые должен решать продукт
>- Опрос стейкхолдеров
>- Выявление аудитории, которая будет пользоваться решением
>- Оценка ресурсов, которые нужны для реализации: количество сотрудников, время, бюджет
>- Согласование критериев, по которым будут оценивать успешность решения

> [!question]- Кто участвует?
>- Руководитель проекта
>- Владелец продукта
>- Заказчик
>- Бизнес/системный аналитик
>- Стейкхолдеры

### Анализ

> [!tldr]- Кратко!
> На этом этапе формируются системные требования (функциональные/нефункциональные)

После составления комплексного плана проекта и выделения необходимых ресурсов ваша команда должна **начать анализировать каждое требование** к ПО, чтобы **определить, как должно функционировать решение**. На основе этого анализа разработчики могут создать подробный список системных спецификаций, который поможет направлять последующие этапы SDLC.  
  
Рассмотрите возможность **визуализации работы вашего решения с помощью *схем вариантов использования* и *схем потоков данных***, чтобы предоставить командам понятные представления функций и структуры программного обеспечения. Это помогает подтвердить, будет ли ПО соответствовать требованиям заинтересованных лиц, снижая вероятность дорогостоящих недоразумений и переработок в будущем.

> [!todo]- Проводимые работы
>- Оценка рисков
>- Выбор методологии работы
>- Описание пользовательских сценариев
>- подготовка SRS — документации с информацией о функциональных и нефункциональных требованиях
>- подготовка ИСР — иерархической структуры работ. Процесс разделяют на более мелкие элементы, чтобы упростить управление и понять, в каком порядке нужно выполнять проект, и какие задачи можно делать параллельно друг другу

> [!question]- Кто участвует?
>- Руководитель проекта
>- Владелец продукта
>- Системный аналитик
>- Архитектор
>- Команда разработки

### Проектирование

> [!tldr]- Кратко!
> На этом этапе формируется проектная документация - прототипы дизайны, архитектура и прочие компоненты системы

На этом этапе ваша команда должна **выбрать общую архитектуру ПО** и **определить, как ключевые компоненты могут взаимодействовать друг с другом**. Создание детализированных схем и моделей системы имеет важное значение для выявления потенциальных проблем на ранних этапах и обеспечения того, что конечный продукт соответствует всем потребностям пользователей и ожиданиям заинтересованных лиц.  
  
**Шаблоны проектирования** ускоряют этот этап SDLC, предоставляя проверенные, многоразовые решения для решения распространенных проблем проектирования программного обеспечения. Кроме того, **инструменты прототипирования** помогают визуализировать пользовательские интерфейсы и функции системы, упрощая создание макетов дизайна.

> [!todo]- Проводимые работы
>|   |   |
>|---|---|
|**Верхнеуровневое проектирование**|**Низкоуровневое проектирование**|
|Основные компоненты системы — например, модули, сервисы или подсистемы|Принцип работы отдельных компонентов системы|
|Принцип взаимодействия этих компонентов между собой|Алгоритмы, структуры данных и логика работы внутри каждого модуля|
|Общая архитектура системы — например, клиент-серверная архитектура или микросервисы|Детали реализации — например, какие классы, методы или функции будут созданы|
|Зависимость решения от других систем|Взаимодействие с базами данных, API или другими внешними системами|
|Прототип интерфейса||

> [!question]- Кто участвует?
>- UX/UI-дизайнер
>- QA-инженер
>- Системный аналитик
>- Архитектор
>- Команда разработки

### Разработка

> [!tldr]- Кратко!
> На этом этапе формируется итоговый продукт

Задача команды на этом этапе **преобразовать спецификации дизайна и системные требования в фактический код**. Цель состоит в том, чтобы создать полнофункциональное программное решение, готовое к тестированию и развертыванию. Этап разработки обычно итеративный, разработчики часто возвращаются к своему коду и уточняют его, чтобы *устранять технические проблемы* или в связи с *изменениями требований*.  
  
Команды разработки часто тесно сотрудничают, чтобы обеспечить правильную интеграцию каждого компонента ПО и их корректное совместное функционирование. **Желательно установление стандартов и рекомендаций по написанию кода**, чтобы поддерживать ваш код был простым и удобным в обслуживания, а также **внедряйте [[Системы контроля версий|системы контроля версий]]** для улучшения управления каждым внесенным изменением. 

> [!todo]- Проводимые работы
>- Написание кода
>- Подготовка тестов
>- Интеграция компонентов

> [!question]- Кто участвует?
>- Разработчики
>- Техлид
>- DevOps-инженер
>- QA-инженеры

### Тестирование

> [!tldr]- Кратко!
> На этом этапе проверяется, что продукт соответствует требованиям

После написания кода ваша команда должна провести комплексное тестирование, чтобы убедиться в готовности к развертыванию. Этот этап оценивает, соответствует ли ваше решение ожиданиям заинтересованных лиц, требованиям безопасности и потребностям пользователей. Ваши конкретные тесты могут различаться от проекта к проекту.
  
> [!info]- Виды тестирований:
>- **Модульное тестирование.** Оцените функциональность каждого конкретного модуля и функции вашего программного обеспечения.
>- **Тестирование интеграции.** Определите, как различные компоненты вашего программного обеспечения взаимодействуют друг с другом.
>- **Системное тестирование.** Разработайте тестовые среды и оцените работу вашего решения в различных системах.
>- **Пользовательское тестирование (UAT).** Выберите бета-тестировщиков для оценки производительности вашего программного обеспечения, предоставления отзывов и выявления ошибок.

Начните с разработки плана с конкретными тестовыми случаями, которые ваша команда может отслеживать. Ваша стратегия должна определять такие элементы, как объем, график и цели для каждого из ваших тестов. Это помогает структурировать весь процесс, сохраняя его сосредоточенным и эффективным от начала до конца.

> [!todo]- Проводимые работы
>- Составление плана тестирований
>- Проведение тестирования
>- Составление отчётов об ошибках и необходимых доработках

> [!question]- Кто участвует?
>- QA-инженеры
>- Разработчики
>- Системный аналитик
>- Пользователи^[В случае пользовательского тестирования!]

### Развертывание

> [!tldr]- Кратко!
> На этом этапе ПО поступает к пользователям

После того как тесты подтвердят, что ваше программное обеспечение соответствует всем необходимым требованиям и стандартам, ваша организация готова предложить решение конечным пользователям. Начните с компиляции финальной сборки вашего программного обеспечения и подготовки рабочей среды, включая серверы, базы данных и сетевые конфигурации. Затем скоординируйте ресурсы и запланируйте задачи (а также реализуйте стратегии отката, которые помогут вам вернуть систему в предыдущее стабильное состояние в случае возникновения проблем), чтобы обеспечить плавное развертывание.

> [!todo]- Проводимые работы
>- Установка ПО на серверы
>- Размещение в магазинах приложений
>- Написание пользовательской документации

> [!question]- Кто участвует?
>- DevOps-инженер
>- Разработчики
>- Системный аналитик
>- Руководитель проекта

### Поддержка

> [!tldr]- Кратко!
> На этом этапе происходит работа с обновлениями ПО и техподдержка пользователей

Последний этап SDLC является *непрерывным* и начинается сразу после развертывания. Обслуживание ПО помогает гарантировать, что оно будет функционировать корректно, оставаться безопасным и соответствовать меняющимся потребностям пользователей с течением времени.  

> [!todo]- Проводимые работы
>- **Мониторинг производительности.** Отслеживайте производительность вашего программного обеспечения, чтобы выявлять и устранять потенциальные проблемы. Кроме того, собирайте отзывы пользователей, чтобы определять области для улучшения.
>- **Исправление ошибок.** Собирайте и анализируйте журналы ошибок, чтобы находить и ранжировать ошибки, а также разрабатывать их исправления.
>- **Предоставление обновлений.** Добавляйте новые функции, улучшайте существующие и устраняйте уязвимости безопасности в программном обеспечении.
>- **Предоставление поддержки.** Предоставляйте пользователям информацию и рекомендации, которые помогут им использовать и понимать различные функции и обновления.

> [!question]- Кто участвует?
>- Техническая поддержка
>- Разработчики
>- Системный аналитик

### Смерть ПО^[если таковая имеет место]

На этом этапе команда прекращает обслуживать продукт или заменяет его новой версией, потому что ПО устарело или такая инициатива поступила от заказчика. Процесс может включать архивирование данных и уведомление пользователей.

### Пример жизненного цикла^[компания AGIMA]

![[image-2025.11.15 Жизненный цикл разработки программного обеспечения-1.png]]

***

## Модели жизненного цикла разработки ПО
```
Модели SDLC возникают как резльтат поиска  оптимальных методов в различных, зачастую меняющихся, внешних и внутренних условиях проекта.
```
### Каскадная/водопадная модель (Waterfall) 
```
Линейный подход к разработке, требующий от команд завершения каждого этапа перед переходом к следующему. Модели водопада просты и понятны, но в них отсутствует гибкость, что затрудняет внесение изменений после завершения этапа.
```
![[image-2025.11.15 Жизненный цикл разработки программного обеспечения-2.png]]
> [!success]- Преимущества
>- Полное документирование каждого этапа до начала разработки
>- Низкий риск ошибок за счет детальной документации
>- Прозрачность процессов для заказчика — он знает, сколько времени уйдет на каждый этап

> [!failure]- Недостатки
>- Перед стартом нужно подготовить обширную техническую документацию, что занимает много времени
>- Сложно учесть все требования до старта разработки
>- Нет гибкости — если появились новые требования на этапе разработке, то откатить работу назад не получится
>- Заказчик видит результат в конце разработки — если итог его не устроит, придется начинать сначала

> [!tip]- Идеально подходит когда
>- Есть четкие и заранее известные требования, которые не будут меняться на этапе разработки 
>- Работа должна идти по строгим регламентам — такое требование может быть актуальным для госучреждений или банковских систем

### V-образная модель 
```
Это расширенный вариант каскадной модели, который делает упор на тестировании. Устроена модель так: до начала разработки после каждого этапа проводят тестирования разного уровня, а после разработки ПО проходит те же самые тестирования в обратном порядке и только потом уходит в релиз. Тестирования до разработки нужны для верификации (проверка соответствия правилам), а тестирования после для валидации (проверка соответствия ожиданиям)
```
![[image-2025.11.15 Жизненный цикл разработки программного обеспечения-3.png]]
> [!success]- Преимущества
>- Ошибки выявляют на ранних этапах, что снижает затраты на их исправление
>- За счет четкой структуры подходит для проектов с ясными и неизменными требованиями
>- Акцент на тестировании обеспечивает надежность продукта
>- Высокая степень анализа рисков

> [!failure]- Недостатки
>- Такая же строгая, как и каскадная, поэтому при появлении новых требований все придется начинать заново
>- Разработка обходится дорого

> [!tip]- Идеально подходит когда
>- Есть четкие и заранее известные требования, которые не будут меняться во время разработки 
>- Работа должна идти по строгим регламентам
>- Проект предполагает большое тестовое покрытие

### Итеративная модель
```
В отличие от водопадной модели, итеративная позволяет обновлять требования к продукту после старта разработки. Для этого проект дробят на части и сначала выпускают MVP-версию, а затем итерациями доводят решение до ума. По ходу разработки требования к ПО можно менять в зависимости от обратной связи пользователей, заказчика или изменений на рынке. Цикл повторяется до тех пор, пока вся система не будет готова.
```
![[image-2025.11.15 Жизненный цикл разработки программного обеспечения-4.png]]
> [!success]- Преимущества
>- Возможность быстро выкатить ПО
>- Заказчик видит промежуточные результаты и может корректировать требования
>- Быстрая обратная связь от пользователей
>- Проще находить конфликты между требованиями

> [!failure]- Недостатки
>- Могут возникнуть сложности с созданием рабочей архитектуры, так как изначально не всегда известны все требования

> [!tip]- Идеально подходит когда
>- Рабочее решение нужно в короткие сроки 
>- Требования не до конца ясны и могут меняться в процессе работы
>- Проект очень большой, а ресурсов немного, поэтому приходится разбивать продукт на части и делать его постепенно

### Инкрементная модель
```
При работе по этой модели продукт создают по частям, или инкрементам. Каждая часть добавляет новую функциональность к уже существующей системе. В отличие от итеративной модели, где каждая итерация может пересматривать и улучшать предыдущие результаты, в инкрементной модели каждая часть — это законченный кусок функционала, который можно использовать.
```
![[image-2025.11.15 Жизненный цикл разработки программного обеспечения-5.png]]
> [!success]- Преимущества
>- Пользователи могут начать использовать продукт уже после первого инкремента
>- Заказчик видит прогресс и может вносить правки в следующие инкременты

> [!failure]- Недостатки
>- Если команды параллельно работают над разными инкрементами, есть риск того, что модули будет сложно связать
>- Необходимо тщательное планирование, чтобы заранее определить, какие функции будут в каждом инкременте, и учесть их в архитектуре

> [!tip]- Идеально подходит когда
>- Рабочее решение нужно в короткие сроки 
>- Требования не до конца ясны и могут меняться в процессе работы
>- Проект очень большой, а ресурсов немного, поэтому приходится разбивать продукт на части и делать его постепенно

### Спиральная модель
```
Модель объединяет в себе преимущества каскадной и итеративной моделей, но делает большой упор на анализ рисков. То есть, команда уделяет много времени планированию и при этом в будущем может дорабатывать решение. Еще одна особенность модели в том, что процесс разработки делится на циклы, которые изображают как витки спирали. И каждый виток состоит из четырех этапов планирование -> анализ рисков -> разработка и тестирование -> оценка работы.
```
![[image-2025.11.15 Жизненный цикл разработки программного обеспечения-6.png]]
> [!success]- Преимущества
>- Риски находят на ранних этапах, что снижает вероятность проблем в будущем
>- Можно вносить изменения в проект по мере его развития
>- Подходит для крупных систем, где много неопределенности и высокие требования к надежности

> [!failure]- Недостатки
>- Многочисленные циклы растягивают разработку и делают ее дороже
>- Каждое новое требование заказчика запускает новый виток

> [!tip]- Идеально подходит когда
>- Пользователи сами не до конца понимают, что им нужно 
>- Требования к проекту слишком сложные и могут меняться по ходу работы
>- Успех проекта не гарантирован, и нужно заранее оценить риски, чтобы решить, стоит ли продолжать работу
>- В проекте используют новые технологии, которые еще не до конца изучены, и есть риск, что они не дадут ожидаемого результата

### Гибкая модель (Agile)
```
Итеративный подход, который разбивает разработку программного обеспечения на более мелкие, управляемые единицы, называемые спринтами. Каждый спринт включает в себя планирование, написание кода, тестирование и проверку, что позволяет командам постоянно улучшать свои решения и добавлять новые функции на протяжении всего процесса разработки. Хотя гибкие модели обеспечивают дополнительную гибкость, они часто требуют большего вовлечения со стороны заинтересованных лиц и участников команды, чем другие модели.
```

> [!abstract]- Принципы Agile:
>- люди и взаимодействие важнее процессов и инструментов
>- рабочий продукт важнее документации
>- сотрудничество с заказчиком важнее согласования условий контракта
>- готовность к изменениям важнее следования плану

К Agile существует несколько подходов:

#### Scrum
```
В основе этого фреймворка лежат короткие спринты, которые обычно длятся по 2-4 недели.  В конце каждого спринта команда выпускает рабочий продукт, а затем проводит ретроспективу, где обсуждает итоги работы, сильные стороны команды и точки роста.
```
![[image-2025.11.15 Жизненный цикл разработки программного обеспечения-7.png]]
> [!success]- Преимущества
>- Можно быстро реагировать на изменения требований
>- Заказчик видит рабочий продукт уже через несколько недель
>- Постоянная обратная связь, так как проходят регулярные демонстрации и обсуждения с заказчиком
>- Короткие итерации и видимый прогресс вдохновляют команду

> [!failure]- Недостатки
>- Зависимость от заказчика, ведь если он не участвует в процессе, подход теряет смысл
>- Зависимость от вовлеченности сотрудников
>- Не всегда есть возможность детально оценить риски

> [!tip]- Идеально подходит когда
>- Требования к проекту нечеткие или часто меняются 
>- Заказчик активно вовлечен в процесс
>- Команда готова к самоорганизации и сотрудничеству

#### Kanban
```
Это не готовая структура процессов, а подход, который улучшает работу по уже выбранной модели. То есть, Kanban не используют вместо текущей методологии, а добавляют к ней, чтобы сделать работу более гибкой и прозрачной.
```
![[image-2025.11.15 Жизненный цикл разработки программного обеспечения-8.png]]
> [!success]- Преимущества
>- Легко внедрить подход
>- Легко адаптируется под изменения, так как подход включает получение обратной связи
>- Все видят, какие задачи в работе и на каком этапе они находятся, что повышает прозрачность процессов
>- WIP-лимиты помогают избежать многозадачности

> [!failure]- Недостатки
>- Может быть сложно организовать работу команды от 10 человек

> [!tip]- Идеально подходит когда
>- Ограничений у канбан-метода нет, но в первую очередь он подходит командам, которые делают упор на прогнозировании сроков работы

***

### Как выбрать правильную модель SDLC
```
В выборе модели SDLC необходимо опираться на ваши проектные потребности и условия. В больших проектах часто используется одновременное использование нескольких моделей для различных задач.
```

> [!abstract]- Инструмент для выбора!
> [Agile Suitability Filter](https://suitabilityfilter.com/)
В опросе присутствуют вопросы:
> - Есть ли у команды постоянный доступ к заказчику?
>- Поддерживает ли спонсор гибкие методологии?
>- Насколько вы уверены в том, что команда понимает ваша видение?
>- Может ли команда сама принимать решения?
>- Можно ли поставлять продукт частями?
>- Как часто меняются требования к продукту?
>- Какой размер команды?
>- Насколько критичные проблемы будут в случае дефектов?
>- Насколько большой опыт у команды?

## Для самых любознательных:

> [!info]- Другие методологии:
>- Управление жизненным циклом приложений (ALM)
>- Жизненный цикл разработки продукта (PDLC)
>- Управление жизненным циклом разработки систем (SDLCM)
>- Жизненный цикл тестирования программного обеспечения (STLC)

> [!example]- Дополнительные материалы: 
>1. [Жизненный цикл разработки программного обеспечения](https://www.microsoft.com/ru-ru/power-platform/topics/phases-of-the-software-development-lifecycle)
>2. [База про жизненный цикл разработки ПО (SDLC): этапы, виды моделей и их различия](https://habr.com/ru/companies/kaiten/articles/893866/?ysclid=mge63r3kst71774572)
>3. [Ещё раз про семь основных методологий разработки](https://habr.com/ru/companies/edison/articles/269789/?ysclid=mge67gipx5989388554)


 
 